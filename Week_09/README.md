### 字符串问题

字符串是我们编程中最常见的，有很多对字符串的操作可以通过高级语言中的 api 完成，比如翻转字符串。所以要熟悉一些常见的 api。

在求解字符串问题时，常常可以用动态规划来解决，通常是用一个二维数组，把要解决的字符串问题映射成状态，然后相当于在一个表格中，逐步推出最终的解。

以 [编辑距离](https://leetcode-cn.com/problems/edit-distance/) 问题举例，我们可以把给定的两个字符串转换为一个二维数组表示，相当于在一个表格中，横向代表一个字符串，纵向代表另一个字符串。


|  |h  | o | r |s  |e  |
| --- | --- | --- | --- | --- | --- |
|r  |  |  |  |  |  |
| o |  |  | * |  |  |
| s |  |  |  |  |  |

把问题抽象成求出每个格子中的值，比如在 * 的位置，是求 hor 经过编辑变为 ro 的距离。

列出状态转移方程

如果两个字符相等：
dp[i][j] = dp[i-1][j-1]

如果两个字符不相等：
dp[i][j] = Math.min(Math.min(dp[i-1][j],dp[i][j-1]),dp[i-1][j-1]) + 1


两个字符相等的情况下，这个位置就不需要编辑，直接都去掉这个字符，看前面的字符的情况。

两个字符不相等的情况下，就要比较三种操作，找到一个最小值，这三种操作分别是

dp[i-1][j] 删除，相当于 hors -> ros 删掉一个字符，然后进行编辑。

dp[i][j-1] 添加，horse -> ro 经过这个转变，在添加一个 s

dp[i-1][j-1] 替换最后一个字符

最终退出表格右下角的值，就是我们问题最终的解。

### Rabin-Karp 算法

字符串匹配时，如果暴力匹配效率不高，为了提升效率，提出 Rabin-Karp 算法，该算法优化的点在于，首先把要匹配的短的子串，计算好 hash 值，然后向滑动窗口一样，在待匹配的长串，每挪动一个字符，都计算一下 hash 值，计算 hash 值的算法经过设计可以做到 O(1) 的时间复杂度，就大大的提高了效率，当发现两个 hash 值相等时，在对子串进行逐位的比较。有点类似布隆过滤器，先过滤掉明显不匹配的，然后大致匹配再进行精确匹配。

