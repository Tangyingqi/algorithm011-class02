### week1

第一周的学习中，我们先学习了正确的方法，也就是对知识的掌握要多过遍数，并且碰到想不出的算法不要死磕，可以学习别人的算法，然后消化后成为自己的东西，因为我们都是这样学习的，很难凭空产生，只有建造好稳固的基础，才能举一反三形成自己的思想。

还学习了一些基础的数据结构，有数组、链表、跳表、栈、队列，队列又包括双端队列和优先队列。

数组是我们最常用的数据结构，它会根据数据大小分配固定的空间，把数据连续的存储在这块空间。它的缺点是添加和删除的复杂度高，因为挪动元素。所以出现链表来应对频繁添加和删除的问题。链表也有它的问题，就是查找相比数组慢很多，要遍历整个链表。所以又出现了更高级的跳表，平衡增删查，复杂度都为 O(logN)。跳表的思路是增加多级索引，查找的速度就变快了。

栈和队列在我们解决查找树中元素问题时特别常用，在后面的深度优先搜索和广度优先搜索中，都要用到这两个数据结构。双端队列用于解决滑动窗口问题非常好用。优先队列是可以根据我们给定的排序规则为我们数据排序，所以在启发式搜索中我们用优先队列存储元素，可以更快的对问题空间树进行遍历。


### week2

第二周我们学习了 Map 在 Java 中我们最常用的 HashMap，底层是数组加链表，当链表超过阈值会变成红黑树。

然后引出树，树有二叉搜索树，它的特点是左子树小于根节点，右子树大于根节点，要注意是所有的左子树右子树，也就是递归这个树都符合这个条件。因为它的这个特性，所以搜索起来很快，是 O(logN) 的。

通过树又引出递归，因为对树进行遍历，最好的就是用递归，数本身就符合递归的概念。

二叉堆是一颗完全二叉树，它可以迅速找到最大值和最小值。在程序中可以存储在数组中，因为它严格意义上除了叶子节点为空，其他都不为空。

### week3

第三周重点学习了递归，递归是很多算法的基础，如分治回溯，因为在很多时候，我们面对的问题都可以构建成一棵树，然后就要递归的遍历这颗树找到答案。

学习递归一定不要人肉进行递归，可以先画出状态树，然后要找到最近重复子问题。

很多时候我们面对一颗状态空间树，这棵树的很多路径并不是问题的答案，但不遍历是无法得知的，就要进行回溯，当我们遍历到一个点发现已经不是我们要的答案了，就回到上一层，并记录下这条路径走不通，然后再去遍历其他的路径。

### week4

这周我们系统的学习了 DFS 和 BFS。

DFS 用栈来实现，BFS 用队列实现。DFS 就是从上到下一头扎进树里，探到树的最深处，再回来，上下反复，顾名思义它就是深度优先。

BFS 是像水波纹一样，一层一层的扩散，从树的上面一层层扩散到下面，所以找最短路径时，我们会用 BFS 来进行搜索。

还学习了贪心算法，这个算法有点像动态规划，不同之处是动态规划会保存走过的路径，而贪心是一条路走到黑。它只关心局部的最优解，所以只有当每一步的局部最优解能推出最终最优解时，才能用贪心来解决。

二分查找也是比较常用的算法，它在我们生活中也非常常见，所以理解起来非常容易。但是写二分查找的麻烦之处在于边界条件，大于小于返回值的选取，只能勤加练习才能更好的掌握这个算法。


### week6

动态规划，非常神奇的一个算法。它最早不是计算机领域的，而是运筹学，很多其他领域都有它的应用。做这一类问题是比较有趣的，并且代码写起来比较简单，可能短短几行代码就解决了很复杂的问题，但越看似简单的东西越复杂。

动态规划可以说是最难很好的掌握的算法之一了，因为它非常考验我们把复杂的问题抽象成子问题，然后提炼出一个动态规划方程的能力。

在不了解动态规划的时候，听这个名字就让人望而却步，但学起来发现没有想象的那么高深，简单的说就是找到一个递推公式，然后不断地递推，最后找到问题的解。

如果学习了前面 DFS 和 BFS 解决的一些问题，或者对递归有一定的了解了，就能更深刻的理解动态规划。可以把 DP 看成是递归反过来，它不递归了，直接迭代。然后前面那样递归的搜索，如果不加任何缓存会发现状态树非常恐怖，拿菲波那切数列举例，它的树的节点是指数级的，所以我们递归时会加上一个数组作为缓存，把这个递归操作反过来变成迭代，加缓存，就很像 DP 了。

### week7

这周学习了一些比较高级的数据结构。

Trie 树，又叫字典树，它的出现是为了查找字符，类似在搜索引擎，打一个字，它会根据这个字联想出其他的内容。

并查集，它是为了解决连通性的问题，比如你想测试一些数据之间的连通性，就可以把数据放入并查集中。

还学习了双向 BFS，它跟单向的区别是，不用 queue 来存节点了，而是用两个 Set，对应着树的两边，然后向中间搜索，跟单向 BFS 相比，它能更少的遍历节点，且更快的找到解。

平衡二叉树，有很多的种类，其中比较常用的有 2-3 Tree、AVL、B-Tree、Red-black Tree

AVL 是严格平衡的二叉树，它每个节点都保存一份 balace factor 平衡因子，要求它的绝对值不能大于 1。如果不满足就要进行旋转。

一般严格会有一定好处也会带来坏处，就是有时不需要那么严格，导致频繁的旋转，所以红黑树，就是近似平衡的，它保证任意节点的左子树和右子树高度差不超过两倍。

红黑树有五条基本性质：

- 每个节点是红色或黑色
- 根节点是黑色
- 每个叶子节点是黑色
- 不能有相邻两个红色节点
- 从任一节点到其他每个叶子节点所有路径都包含相同数目的黑色节点

### week8

这一周学习了位运算

用位运算解八皇后问题像“机器语言”一样，非常巧妙，但非常难懂，看了好久，希望以后能写出这样的代码。

布隆过滤器，是一个很长的二进制数组和一系列的随机映射函数，它可以用于第一层过滤，它的特点是能非常快的识别，并且占用空间少。但有一定的误识别率，因为如果一个元素被布隆过滤器认定为存在的话，其实它不一定存在，要进入下一层再判断，但是认定它不存在的话，那么可以肯定，这个元素不存在。

LRU cache 底层是 HashMap + 双向链表，HashMap 的作用是可以快速找到定位元素的位置，双向链表是为了存储有序，并且方便增删和修改数据的位置。

排序算法，可以分为两类，一类是比较类排序，一类是非比较排序，第一类用的比较多，因为我们一般是对对象排序，它的复杂度无法突破 O(nlogn)

### week9

学习了字符串相关的问题，还有一些高级的字符串匹配算法，比较常用的有 Rabin-Karp 和 KMP。

### 总结

通过九个星期的学习，结束了算法训练营的全部课程。这九周收获很多，不仅是知识技能上的提升还有思想上的提升。在面对复杂的知识或问题时，借鉴算法中的思想，应该把大问题分解成子问题，一步步突破，在这个过程中，要不断地重复练习，一方面是加深理解，还有就是对抗遗忘曲线。人的大脑会不断清理掉一些记忆，通过学习会发现，一开始学发现自己已经掌握了，过一段时间再看已经丢失了部分信息，所以要不断的提取记忆，让记忆加深，才能形成永久记忆。