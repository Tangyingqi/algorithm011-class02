#### 递归

递归就是函数自己调用自己，每一层都是一个新的环境，跟其他层互不干扰，但是传进去的参数可以保留一些状态信息。

递归可以理解为，每一层解决一个子问题，它一般用来解决树形问题，就是一个问题，有不同的选择，然后向下生成一棵树，那么每一层就相当于一个子问题，当我们递归访问到最下层的叶子节点的时候，这个问题的所有子问题就解决了，然后在不断地向上回溯。

##### 递归模板
```java
public void recur(int level, int param) { 
  // terminator 
  if (level > MAX_LEVEL) { 
    // process result 
    return; 
  }
  // process current logic 
  process(level, param); 
  // drill down 
  recur( level: level + 1, newParam); 
  // restore current status if needed
 
}
```
###### terminator

首先我们在实现递归的时候，要先考虑它的终止条件，否则就成了无限递归。终止条件一般是传进来的参数与一个边界值进行比较。比如在排列组合问题中我们会传进来一个 list 用于储存遍历的路径，当我们到达最下面一层，也就是 list 中存储的路径个数已经符合我们想要的个数，那么就可以结束这个递归了。

###### process current logic

我们在这个函数中，主要是要对问题进行处理，每一层都会对子问题进行处理然后传递给下一层。

###### drill down

当我们处理完这一层的问题，就要下探到下一层，带着这一层问题的答案，以及我们要把层级 level + 1 

###### restore current status

这个步骤不是必须的，比如在解决菲波那切数列和反转二叉树这些问题时，用递归实现，没有做任何存储，所以不需要进行清理。那什么情况需要清理呢？比如在解决排列组合问题，或者说遍历一颗搜索树，需要用 list 保存每一条遍历的路径，这条路径即这个 list 就是一个子问题的解，那么我们在遍历到树的最底层，再回退回来的时候，这一路上，就要对状态进行清理，因为我们在回到起始位置的时候，要重新出发去遍历。所以在面对这类问题，要注意的一个点是，在 terminator 中保存 result 的时候，要进行拷贝，否则我们的状态就会被清理掉了，最终的结果就是空了。

##### 递归思维要点

- 不要人肉进行递归
- 找最近重复子问题
- 数学归纳法


人脑是无法接受递归这种思维模式的，所以人肉递归是行不通的，在一开始可以在纸上把状态树画出来帮助理解。递归本质就是把大问题拆解成小问题，并且这个小问题是可以重复的，那么就可以递归的进行解决。数学归纳法，是思考简单的情况，n=1 n=2 是成立的，进而 n 的时候也是成立的。

#### 分治 & 回溯

递归是一个概念，分治和回溯就是递归的具体实现，它们本质上就是递归。





