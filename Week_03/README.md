#### 递归

递归就是函数自己调用自己，每一层都是一个新的环境，跟其他层互不干扰，但是传进去的参数可以保留一些状态信息。

递归可以理解为，每一层解决一个子问题，它一般用来解决树形问题，就是一个问题，有不同的选择，然后向下生成一棵树，那么每一层就相当于一个子问题，当我们递归访问到最下层的叶子节点的时候，这个问题的所有子问题就解决了，然后在不断地向上回溯。

##### 递归模板
```java
public void recur(int level, int param) { 
  // terminator 
  if (level > MAX_LEVEL) { 
    // process result 
    return; 
  }
  // process current logic 
  process(level, param); 
  // drill down 
  recur( level: level + 1, newParam); 
  // restore current status if needed
 
}
```
###### terminator

首先我们在实现递归的时候，要先考虑它的终止条件，否则就成了无限递归。终止条件一般是传进来的参数与一个边界值进行比较。比如在排列组合问题中我们会传进来一个 list 用于储存遍历的路径，当我们到达最下面一层，也就是 list 中存储的路径个数已经符合我们想要的个数，那么就可以结束这个递归了。

###### process current logic

我们在这个函数中，主要是要对问题进行处理，每一层都会对子问题进行处理然后传递给下一层。

###### drill down

当我们处理完这一层的问题，就要下探到下一层，带着这一层问题的答案，以及我们要把层级 level + 1 

###### restore current status

这个步骤不是必须的，比如在解决菲波那切数列和反转二叉树这些问题时，用递归实现，没有做任何存储，所以不需要进行清理。那什么情况需要清理呢？比如在解决排列组合问题，或者说遍历一颗搜索树，需要用 list 保存每一条遍历的路径，这条路径即这个 list 就是一个子问题的解，那么我们在遍历到树的最底层，再回退回来的时候，这一路上，就要对状态进行清理，因为我们在回到起始位置的时候，要重新出发去遍历。所以在面对这类问题，要注意的一个点是，在 terminator 中保存 result 的时候，要进行拷贝，否则我们的状态就会被清理掉了，最终的结果就是空了。

##### 递归思维要点

- 不要人肉进行递归
- 找最近重复子问题
- 数学归纳法


人脑是无法接受递归这种思维模式的，所以人肉递归是行不通的，在一开始可以在纸上把状态树画出来帮助理解。递归本质就是把大问题拆解成小问题，并且这个小问题是可以重复的，那么就可以递归的进行解决。数学归纳法，是思考简单的情况，n=1 n=2 是成立的，进而 n 的时候也是成立的。

#### 分治 & 回溯

递归是一个概念，分治和回溯就是递归的具体实现，它们本质上就是递归。

分治我的理解是它分解成子问题后，同时向下去遍历由若干子问题生成的数，最终遍历到最底层的节点，也就是找到了问题的解，然后要把所有子问题的解进行 merge 操作，最终得到整个问题的解。

回溯是首先遍历其中一颗子树，找到这个子问题的解或者发现遍历完成这颗子树没有找到问题的解，就要向上进行回溯，同时恢复这条遍历下来这条路径的状态，然后再进行遍历另一颗子树，直到遍历完所有的子树。

例如求二叉树的最大最小深度，是同时遍历整个树，最终把问题的解进行合并，找到最终解。这是一种分治的思想。

在排列组合问题中，比如电话号码的组合以及 N 皇后问题，都是一种排列组合问题。在这种问题，要考虑使用回溯的思想，不断的遍历其中一颗子树，找到问题的解，保存下来，然后继续遍历其他的子树。这里就要注意，恢复之前的状态。

在组合问题中，我们要传入每一层遍历的起始位置，因为它是向后遍历的，所以在我们循环遍历的时候，起始位置都是不断向后的。

```java
private void backtrack(int n, int k, int start, LinkedList<Integer> list) {

        if(k == list.size()){
            output.add(new LinkedList<>(list));
            return;
        }
        // start 是我们需要传入的起始位置，每层遍历都从上一层的基础上 +1
        for(int i=start;i <= n-(k - list.size()) +1 ;i++){
            list.add(i);
            backtrack(n,k,i+1,list);
            list.removeLast();
        }
    }
```

在排列问题中，跟组合不同的是，我们循环遍历都要从 0 开始，因为我们要遍历整个数组，但是我们需要一个容器来存储上一层已经遍历过的数，防止重复遍历。

```java
   // 每一层都要传入 used ，防止重复遍历
   private void dfs(int[] nums,int depth,List<Integer> list,Set<Integer> used){
        if(nums.length == depth){
            output.add(new ArrayList<>(list));
            return;
        }

        for(int i=0;i<nums.length;i++){
            if(!used.contains(i)){

                list.add(nums[i]);
                used.add(i);
                dfs(nums,depth+1,list,used);

                list.remove(list.size() - 1);
                used.remove(i);
            }

        }
    }
```
如果比较这些代码，我们会发现区别不大，符合递归的模板，首先要设置终止条件，当我们找到符合答案个数的解时，就停止遍历，然后在循环中，首先保存这一层的数据，进入下一层，然后恢复这一层的状态。

在 N 皇后问题中，同样符合这样的模板，但是我们要根据题目的规则进行剪枝，也就是不符合条件的情况，我们就不去遍历。所以这个问题，最重要的是要判断什么情况下符合条件，什么条件就要剪掉。

#### 总结

分治&回溯是递归的应用，在一个问题可以找到重复子问题，并且它的解会构造出一颗树的时候，我们就要考虑用这种方式解决。这种解法，其实就是遍历整个解空间，不同的问题，就要根据不同的条件，判断怎样剪枝。所以我们抽象的看待这类问题，可以统统归结为排列组合问题，他们的不同点就在于剪枝。如何更有效的剪枝，是影响我们程序性能的关键点。





